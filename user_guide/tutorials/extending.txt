|---------------------------------------------------------------
| TUTORIAL #1: AN INTRODUCTION TO EXTENDING NOVA
|---------------------------------------------------------------

Nova has been designed from the ground up with the idea of extensibility. It's relatively easy to add to or modify Nova's behavior without ever touching the core application files, meaning that when we release an update, your changes stay intact. Let's take a look at how we're going to extend the various pieces of Nova.

CONTROLLERS

Controllers are the heart and soul of Nova. Entire sections and their pages are generated from the controllers and methods. Because of that, controllers are arguably the most important piece that needs to be extensible.

There are two options for extending a Nova controller: adding and modifying. Let's look at each carefully.

In order to add a page to Nova, we have to add a method to the controller. A method is nothing more than a function inside a class. We've worked hard to make sure that it's very easy to jump in and start extending the controllers (assuming you know PHP fairly well). In the controllers directory, you'll notice that the files in there are almost completely empty in addition to a directory called BASE. Base is where Anodyne does all it's work and it's where you'll find all the existing controllers and methods. Main.php is what you can use to add and modify the default behaviors. Anodyne will never update any of the non base controllers!

We'll get to modifying a method later on, but for now, let's say we want to create a page that displays all the ranks. We'll start by opening main.php in a text editor. There are a few things to point out here. First, you'll see that we include the main_base file at the top, this allows us to add and modify the methods in this file and allow them to overwrite what's in main_base. Next, you'll see the class declaration. This should never be changed, otherwise, the system will break! Finally, you'll see the contructor, a method that gets called at the top of every single method by default. After that is where we can start our own method. After the closing bracket of the constructor, add the following code:

function ranks()
{
	echo 'This is my ranks page!';
}

If you were to go to http://yoursite/index.php/main/ranks before you save this file, an error would be displayed that it can't find that page. Once you save main.php and try going to that page, you'll see your text in the browser. That's it. You've just created the first part of a new page in the main section of Nova. In future tutorials, we'll add to this and incorporate models and helpers to display a list of ranks from the database.

|---------------------------------------------------------------
| TUTORIAL #2: TEMPLATES AND VIEWS, OH MY
|---------------------------------------------------------------

Nova uses a simplified template system, accurately named Template. Instead of building the template through multiple pages, a single HTML/PHP file is used and "regions" are defined where content appears. We're not going to get in to the specifics of Template in this tutorial, but one thing we do need to do is to call the template code in our method. So let's pull up main.php and keep working on our new ranks page.

In the last tutorial, we ended up creating a simple method in main.php that looked like this:

function ranks()
{
	echo 'This is my ranks page!';
}

Let's add some meat to this controller and start to break apart the presentation and logic. The first thing we're going to do is add code that tells the template what to do for our page. You can remove the echo statement and ddd the following code to your method (between the braces):

// write the data to the template
$this->template->write('title', 'Ranks');
$this->template->write_view('content', $view_loc, $data);

// render the template
$this->template->render();

These 3 lines of code are paramount to getting Nova to display what we want; these tell the template where to pull the content from. The first line tells our method to write something to the title region, and the second parameter tells it what to write. In this case, we're adding Ranks to the title of the page after the ship name. The second line tells our method to write a view to the content region. The second parameter tells the template where to look for the view file, and the third parameter is actually going to be passing data from the controller method to the view file for the browser to display. Finally, the last line renders the template in it's entirety. NOTE: without the last line, your page won't display, it'll just be a blank, white page.

In the line that writes the view file to the content region, you see the $view_loc variable where I said we were telling the system where to look for our view file. That variable will contain information about where our view file is. In our method, above the code we just added, let's add the following line of code:

// figure out where the view file should be coming from
$view_loc = view_location('main_ranks', $this->skin, 'main');

So what does this code do? We've built a handy little helper for Nova that helps figure out what skin is being used and where it should be pulling view files from. View files are the PHP files that have all the HTML code for our pages. In this case, we're looking for the main_ranks.php view file in whatever the current skin is and in the main section. Of course, that file doesn't exist right now, so we need to create it. Create a file called main_ranks.php in the views/_base/main/pages directory. It should look like this:

<?php echo text_output($header, 'h1', 'page_head');?>
<?php echo text_output($message);?>

One of the advantages of the view_location helper is that it checks the current skin to see if there's a view in the skin's pages directory with that name. If it finds a file, it'll use the skin's version of the file instead of whatever's in _base. For creating a new page, that doesn't do us a lot of good, because then other skins can't use it. However, when we get into modifying existing pages, that'll become a huge part because it allows us to "overwrite" the _base view file with our own, meaning our skin can have a unique layout for a page and it doesn't ever affect the system default.

Back to our new view file. The text_output() part is a helper that will generate our HTML for us.  The first parameter you see is the variable we're passing from the controller (which doesn't exist just yet).  The second parameter is the element you want the text to be wrapped in.  You can use any block-level HTML element here (h1, h2, h3, h4, h5, h6, p, div, span, quote, etc.). In addition, if you don't want it to have an element, you can simply put nothing in between those single quotes.  Finally, the third parameter (which is optional), tells the helper what class to put on the element.  In this case, we're putting our text in an H1 element with a class of page_head.  That's it. If we tried to load the page now, it would generate a few errors though, so let's keep powering through and finish this tutorial up!

Back in main.php, we're going to add two new lines of code after we declare $view_loc:

$data['header'] = 'My Ranks';
$data['message'] = "This is the page where I'm going to see all my rank images!";

Just like that, we've created variables that are passed to the view file. Those two variables we created in the view file? You guessed it, they line up with the names here and will display the data we've set them to. You'll notice that our base variable here is $data and that we passed a variable named $data to our write_view function. Making more sense now? Go ahead and refresh the page in your browser and you'll see the text we put in here.

Congratulations, you've just added a view file and told our method to send our data from the method to the new view file!

|---------------------------------------------------------------
| TUTORIAL #3: MODELS, OOH LA LA
|---------------------------------------------------------------

Static pages are all well in good, but Nova has a wealth of information stored in the database and we want to be able to pull that information out and use it on our new page, right? Absolutely. So now we have to dive in and start messing around with models. In CodeIgniter, models are the way we interact with the database. The model does the heavy lift and sends an object back to the controller method. From there, we can parse the information out and use it in our method and view.

We could use an existing model method for this project, but that would defeat the purpose of learning how to really extend Nova, so we're going to create a new model method and introduce you to Active Record. Much like the controllers directory has a BASE folder, the models folder is the same way. Like the controllers, Anodyne does all of its work in the base folder, allowing you to add or modify model methods without touching core files. The same rules that apply to controllers apply to models. So let's open up models/ranks_model.php in a text editor and create a new method after the constructor.

function get_rank_list()
{

}

The first thing we need to do is select the table where we want to pull our information from. Since we've created this in the ranks model, it makes sense that we're going to be accessing the ranks table. Generally speaking, we have a model for each table of the database. Of course, we've combined a bunch (posts and post comments, for instance, are in the same model). Also, CodeIgniter has a very useful library called Active Record which lets us build queries programmatically. This, potentially, allows Nova to be ported to use a different database platform and still work. So first up, let's grab the table. Add the following line to our method:

$this->db->from('ranks_'. GENRE);

Now, this is an interesting method because we have to take into account the genre we're using. Let's break this down a little further. From is, like it's SQL counterpart, simply a statement that says SELECT something FROM table. With Active Record, if we don't provide a select statement, it automatically uses *, or select everything. Our statement here is selecting everything from nova_ranks_ds9 (assuming we're using the ds9 genre). The nova_ prefix is added by Active Record automatically. If we were to run this query, it would look like SELECT * FROM nova_ranks_ds9. Pretty straightforward. So next line:

$this->db->where('rank_display', 'y');

Now, we're adding a where statement. This statement makes sure we're only pulling rank items that are set to display. This will make our query look like SELECT * FROM nova_ranks_ds9 WHERE rank_display = 'y'. Pretty straightforward. If we wanted to, we could add other operators by adding them right after the first parameter ('rank_display !=' or 'rank_display >', etc.). So now, out method looks like:

$this->db->from('ranks_'. GENRE);
$this->db->where('rank_display', 'y');

$query = $this->db->get();

return $query;

As you can see, we've added two lines, and as you guesed it, they do the actual query. We've assigned the query to a variable aptly named $query. Active Record will run the query and assign the object it returns to that variable. After that, we simply return the query variables so we can use it in our controller method. So in the end, our method looks like this:

function get_rank_list()
{
	$this->db->from('ranks_'. GENRE);
	$this->db->where('rank_display', 'y');

	$query = $this->db->get();

	return $query;
}

Next time, we're going to plug that model in to our controller and use it to pass information from the database right to our view file!

|---------------------------------------------------------------
| TUTORIAL #4: MODELS, OOH LA LA - PART 2
|---------------------------------------------------------------

In the last tutorial, we talked about models and building a simple model method to get all the ranks in the database that are set to display. In the end, we told our model method to return the query object so we can use it in our controller. That's what we're going to do now; we're going to tell our controller to pull the information from the database, assign it to a variable, do some sanity checking, and finally put everything into an array that we can pass to our view (we could pass an object, but Nova tends to pass arrays).

So to review, our controller method currently looks like this:

function ranks()
{
	// figure out where the view file should be coming from
	$view_loc = view_location('main_ranks', $this->skin, 'main');
	
	$data['header'] = 'My Ranks';
	$data['message'] = "This is the page where I'm going to see all my rank images!";
	
	// write the data to the template
	$this->template->write('title', 'Ranks');
	$this->template->write_view('content', $view_loc, $data);

	// render the template
	$this->template->render();
}

Let's start by loading the model. Because of needing to maintain backwards compatability with PHP4, CodeIgniter doesn't support magically loading models when they're used. Some day though. In the meantime, we'll need to load our model. To load the model, put the following line at the top of the method (all inside the brackets):

$this->load->model('ranks_model');

This makes any method of our ranks model available to us by using $this->ranks_model->method_name(). Let's simplify even a little further:

$this->load->model('ranks_model', 'ranks');

Now, we can access our ranks model by using $this->ranks->method_name() instead. It's just a tad simpler. Please refer to the documentation about models to read about the systemwide model naming scheme. If you cross paths with another model, it will cause issues on your page.

Now that we've loaded our model, we can assign our method to a variable, like so:

$ranks = $this->ranks->get_rank_list();

As soon as the server gets to that point, it triggers the model to run and assign the result of the query to an object in the variable $ranks. From here, we can do some sanity checking and then loop through the object and get what we need. First, we're going to make sure there's actually something in the object.

if ($ranks->num_rows() > 0)
{

}

The num_rows() method is built in to CodeIgniter and will give you the number of rows returned in the query. We just want to make sure there's at least one. If there is, it'll execute whatever code we put in between those braces. Now, between those braces, let's loop through the object.

foreach ($ranks->result() as $rank)
{

}

Now, we're taking the results from the ranks object and assigning them to a variable called rank for the duration of the loop. We'll be able to access everything in the object as $rank->field_name. So, let's start building an array to hold all our information that we're going to pass on to the view. Inside the foreach loop braces, let's start assigning things to the array.

$data['ranks'][$rank->rank_id]['name'] = $rank->rank_name;
$data['ranks'][$rank->rank_id]['image'] = $rank->rank_image;

You'll remember that we pass a variable to the view called $data. Well, we're using the same variable, just creating a new array off that variable. In this case, we're creating an array called ranks. The ranks array is multi-dimensional, meaning it has more than 1 level.  You'll also see after the $rank-> is the field name that matches the field we're pulling from the database. In the end, our array is going to look a little like this:

Array (
	[1] => Array(
		[name] => Admiral
		[image] => r-a4
	),
	[2] => Array(
		[name] => Vice Admiral
		[image] => r-a3
	)
)

Of course, this array works, but we want to make sure we're pulling all the information so we can see a full image and not just a path. To do that, we need to add another line of code up at the top of our method:

$extension = $this->ranks->get_rank_extension($this->rank);

What we've done here is assign the rank set's image extension to a variable that we'll be able to re-use throughout our method. The parameter we're passing to the method is a controller-wide (and systemwide) variable that determine the current rank set that's being used. This model method will grab the extension for us to use. Back down in our foreach loop, we're going to take our array another level deeper. Change the image item to look like this:

$data['ranks'][$rank->rank_id]['image'] = array(
	'src' => rank_location($this->rank, $rank->rank_image, $extension),
	'alt' => $rank->rank_name
);

Now, our array looks a little like this (the path name will vary based on your server setup):

Array (
	[1] => Array(
		[name] => Admiral
		[image] => Array (
			[src] => ./application/assets/common/ds9/ranks/default/r-a4.png,
			[alt] => Admiral
		)
	),
	[2] => Array(
		[name] => Vice Admiral
		[image] => Array (
			[src] => ./application/assets/common/ds9/ranks/default/r-a3.png,
			[alt] => Vice Admiral
		)
	)
)

The array will continue as long as it has data to keep putting in there. Now, all we have to do is pass the $data variable to the view and then loop through that variable in the view and we'll have a full list of ranks coming from the database.

To recap, our controller method should look like this:

function ranks()
{
	// load the model
	$this->load->model('ranks_model', 'ranks');
	
	// grab the ranks from the db
	$ranks = $this->ranks->get_rank_list();
	
	// grab the extension
	$extension = $this->ranks->get_rank_extension($this->rank);
	
	// make sure there's something in the object
	if ($ranks->num_rows() > 0)
	{
		// assign the items to an array for the view
		foreach ($ranks->result() as $rank)
		{
			$data['ranks'][$rank->rank_id]['name'] = $rank->rank_name;
			$data['ranks'][$rank->rank_id]['image'] = array(
				'src' => rank_location($this->rank, $rank->rank_image, $extension),
				'alt' => $rank->rank_name
			);
		}
	}
	
	// figure out where the view file should be coming from
	$view_loc = view_location('main_ranks', $this->skin, 'main');
	
	$data['header'] = 'My Ranks';
	$data['message'] = "This is the page where I'm going to see all my rank images!";
	
	// write the data to the template
	$this->template->write('title', 'Ranks');
	$this->template->write_view('content', $view_loc, $data);

	// render the template
	$this->template->render();
}

In our next tutorial, we'll look at what happens on the view side of things to get these to print out in a nice list.

|---------------------------------------------------------------
| TUTORIAL #5: CONTROLLER, MEET VIEW
|---------------------------------------------------------------

We've done the heavy lifting in the controller and model so far and we have all our information. Now, it's time to spit that data out into our view file so that people can see the list of ranks we have available. We'll start by opening the view file we created in our second tutorial. To recap, the view (located at views/_base/main/pages/main_ranks.php) should look like this:

<?php echo text_output($header, 'h1', 'page_head');?>
<?php echo text_output($message);?>

We've already told our controller to pass the information to the view, so we have those items available to us without doing anything special, we just have to use the variables! Let's start by again making sure the variable exists to avoid errors if the query doesn't return anything from our model.

<?php if (isset($ranks)): ?>

<?php endif; ?>

You'll notice we're using a variable called $ranks. Remember that in our controller, we passed the array to the view as $data['ranks']. All we're doing now is removing the $data part and assigning the ranks array to its own variable. Additionally, Nova uses PHP's alternate syntax in view files to keep PHP statements contained to a single line. This makes it easier for people who aren't as familiar with PHP as they don't have to worry about tracking braces and such. Inside that statement, let's loop through our ranks array.

<?php foreach ($ranks as $rank): ?>

<?php endforeach; ?>

Again, we're using the alternate syntax for the foreach loop. This will step through each item in the array and give us access to the values through $rank['key']. Inside our foreach loop, let's spit out the rank information.

<?php echo $rank['name'] .' '. img($rank['image']);?><br />

That will print the name of our rank, a space, then the image. In this instance, we're using a CodeIgniter helper for creating an image tag. Once you've saved the file, you can navigate to your browser and see a full listing of ranks out of the database.

Your view should now look like this:

<?php echo text_output($header, 'h1', 'page_head');?>
<?php echo text_output($message);?>

<?php if (isset($ranks)): ?>
	<?php foreach ($ranks as $rank): ?>
		<?php echo $rank['name'] .' '. img($rank['image']);?><br />
	<?php endforeach; ?>
<?php endif; ?>

That's it. The above is the only presentational code you need and you have a full list of ranks. Congratulations, you've just created a brand new page that has database interactivity! In future tutorials, we'll show you how to modify existing pages and even create your own models and sections from scratch.